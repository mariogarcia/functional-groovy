package groovyfp.streams

import groovyfp.csv.CsvReaderAware

import spock.lang.Specification
import groovy.stream.Stream
import java.nio.file.Paths

class StreamGroovySpec extends Specification {

    // tag::streams_4[]
    void 'Getting double values from even numbers of a given collection'() {
        when: 'Processing the stream'
            def result =
                Stream.
                    from(0..5). // <1>
                    filter { it % 2 == 0 }. // <2>
                    map { it * 10 }. // <3>
                    collect() // <4>
        then: 'We should get the expected results'
            result == [0, 20, 40]
    }
    // end::streams_4[]

    // tag::streams_5[]
    void 'Creating streams'() {
        when: 'building streams from collections and iterables'
            def stream1 = Stream.from({ x++ }).using(x: 1) // <1>
            def stream2 = Stream.from([1, 2, 3]) // <2>
            def stream3 = Stream.from(50..100) // <3>
            def stream4 = Stream.from(x: 0..2, y: 4..2) // <4>
        and: 'from an iterator instance'
            def x = 0
            def iterator = [hasNext: { true }, next: { x++ }] as Iterator
            def stream5 = Stream.from(iterator) // <5>
        and: 'also from another stream'
            def stream6 = Stream.from(stream1) // <6>
        then: 'values generated by the stream invocations'
            stream1.take(2).collect() == [1, 2]
            stream2.take(2).collect() == [1, 2]
            stream3.take(4).collect() == [50, 51, 52, 53]
            stream4.take(2).collect() == [[x:0, y:4], [x:0, y:3]]
        and: 'using until instead of take'
            stream5.until{ it > 3}.collect() == [0, 1, 2, 3]
            stream6.until{ it > 6}.collect() == [3, 4, 5, 6]
    }
    // end::streams_5[]

    // tag::streams_6[]
    void 'Maximum difference in an NBA game: non lazy'() {
        when: 'Csv iterable'
            def result = csv
                    .findAll(byDateFunction)
                    .collect(differenceFunction)
                    .max()
        then: 'The result should be the expected'
            result == 45
    }
    // end::streams_6[]

    // tag::streams_7[]
    void 'Maximum difference in an NBA game: lazy'() {
        when: 'Csv iterable'
            def result =
                Stream
                    .from(csv)
                    .filter(byDateFunction)
                    .map(differenceFunction)
                    .max()
        then: 'The result should be the expected'
            result == 45
    }
    // end::streams_7[]

    // tag::streams_8[]
    def getByDateFunction() {
        return { row ->
           row.date.endsWith('2013')
        }
    }
    // end::streams_8[]

    // tag::streams_9[]
    def getDifferenceFunction() {
        return { row ->
            [row.homePoints, row.visitorPoints]*.
                toInteger().
                sort().
                with {
                    last() - first()
                }
        }
    }
    // end::streams_9[]

    def getCsv() {
        return new CsvReaderAware().
            getCsvFrom(
                Paths.get('src/main/resources/groovyfp/ac/NbaGameService.csv')
            )
    }

}
