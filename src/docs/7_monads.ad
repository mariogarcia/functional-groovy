== The M-Word

=== Functor

Generally speaking a +Functor+ is any type you can map a function over. A +Functor+ represents a
container/wrapper of some sort, along with the ability to apply a function to elements wrapped in
the container 

So a +Functor+ is a container. It contains a value. That value can be transformed
by functions applied to the container. Not to the value directly.

The formal definition of a Functor in Haskell is:

[source, haskell]
.Functor definition
----
class Functor f where
    fmap :: (a -> b) -> fa -> fb
----

What does it mean ? Well it means that in order to build a new instance of a 
+Functor+ type the type should implement a +fmap+ method.

The +fmap+ method receives a function +(a -> b)+ which transforms an object
of type +a+ in another object of type +b+, it also receives a +Functor+ of type +a+ 
and finally returns a functor of type +b+.

How could we implement this ?

==== Implementation

[source, java]
.Functor
----
include::{sourceDirJava}/groovyfp/categories/Functor.java[indent=0] 
----

So basically a functor allows us to transform the contained value applying a function. 
There're some differences between the Java(TM) implementation and the Haskell one.

* +(a->b)+ becomes +Function<A,B>+
* +fa+ parameter will be the instance of the functor itself
* +fb+ becomes +Functor<B>+

Imagine we had a function adding 3 to any number. In Haskell we would be seeing this:

[source,haskell]
.Haskell example
----
fmap (+3) (Just 1)
----

I'll try to reproduce the same behavior, this time with Groovy :) We will be following
these steps:

* We need a function receiving a number and returning a number
* Then the functor will receive the function and will know how to unwrap the
value and after applying the function how to wrap it again.

==== Function (a->b)

A function represents a transformation applied to a given input, giving
a certain result.

We need a function adding 3 to any given number. Here is a simple java interface
defining a function:

[source,java]
.Function
----
include::{sourceDirJava}/groovyfp/categories/Function.java[indent=0] 
----

Because this interface is in fact a functional interface, it could be
substituted by a Closure expression. So instead of building a new class or
building a verbose inner class implementation we will be using a closure
to define a new implementation of the *Function* interface.

[source,groovy]
.Function<Integer,Integer>
----
include::{testDir}/groovyfp/categories/FunctionSpec.groovy[tags=function1,indent=0] 
----

NOTE: Be aware that because closures only declare the return type you should add 
the type to the closure parameter if you care about input type.

==== Functor<A>

Well now we need an instance of a functor of type *A*, pass to the functor
our previously created function and expect to receive a certain value with
a certain type.

[source,groovy]
.Functor<Integer>
----
include::{testDir}/groovyfp/categories/FunctorSpec.groovy[tags=functorspec1,indent=0] 
----

Ok but how +Maybe.Just+ gets something and transform it to another functor. Lets see
what the +fmap+ implementation does:

[source,java]
.Maybe Functor#fmap implementation
----
include::{sourceDirJava}/groovyfp/categories/Maybe.java[tags=functorspec2,indent=0]
----

First I'll try to describe which types are involved:

* +JUST+ is the value contained by the Maybe instance (which among other things is a functor).
* +<B>+ is the type of the function applied. Then
the Maybe implementation wraps that value into another instance of a functor
(this time another Just instance).

Basically here the +fmap+ method takes as an argument a function transforming
the contained value in the source functor and then wraps it again in another
functor instance. 

=== Applicative Functor

Remember I was saying a +Functor+ is a container, a box if you like containing
a simple value. You can think about +Applicative+ like a +Functor+ containing
a +Function+. Why then the name of +Applicative+ ? I'm not quite sure, but
I think it comes from the idea that a function *can be applied* to some other values.



