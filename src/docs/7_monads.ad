== The M-Word

+Category Theory+ is a huge topic not related *per se* to programming, but 
nowadays is the basis of what functional programming has become today.

In this chapter I'll try to explain and give examples of some terms
taken from Category Theory and why they could be useful to us as programmers
in our daily work.

Many of the examples are based on +Haskell+ programming language. 
As a pure functional language is the best place if you want to learn
the basis of functional programming, and also because there aren't
much documentation out there other than Haskell. Here you have
my two cents :)

I'm aware that terms like +Functor+, +Monad+...etc seem to be something
strange, odd, difficult for most of the programmers born in the OOP era 
(including myself by the way).

I know it's difficult... bad news: it becomes harder along the way, good news
... there is no good news. I'm jocking good news is that the more you
learn about +Category Theory+ applied to functional programming the more
you understand how to use functional programming at work... but stop! 
it's about time... *LETS DO THIS* 


=== Functor

In +Category Theory+ a +Functor+ is a mapping between categories...WHaAaAAAaaTT?? O_o

A +Functor+ represents a container/wrapper of some sort, along with the ability 
to apply a function to elements wrapped in the container. 

Ok, so a +Functor+ is like a +container+, like a +box+. It contains a value. 
That value can be transformed by functions applied to the container,
not to the value directly.

The formal definition of a Functor in Haskell is:

[source, haskell]
.Functor definition
----
class Functor f where
    fmap :: (a -> b) -> f a -> f b
----

What does it mean ? Well it means that in order to build a new instance of a 
+Functor+ type the type should implement a +fmap+ method.

The +fmap+ method receives a function +(a -> b)+ which transforms an object
of type +a+ in another object of type +b+, it also receives a +Functor+ of type +a+ 
and finally returns a functor of type +b+.

How could we implement this ?

==== Implementation

[source, java]
.Functor (Java)
----
include::{sourceDirJava}/groovyfp/categories/Functor.java[indent=0] 
----

NOTE: Some of the interfaces or classes shown here are implemented in plain
Java(TM). I'm planning to migrate them to Groovy 2.3+ with +@CompileStatic+ any time
soon.

So basically a functor allows us to transform the contained value applying a function. 
There're some differences between the Java(TM) implementation and the Haskell one.

* +(a->b)+ becomes +Function<A,B>+
* +fa+ parameter will be the instance of the functor itself
* +fb+ becomes +Functor<B>+

Now imagine we had a function adding 3 to any number. In Haskell we would be seeing this:

[source,haskell]
.Haskell example
----
fmap (+3) (Just 1)
----

I'll try to reproduce the same behavior, this time with Groovy :) We will be following
these steps:

* We need a function receiving a number and returning a number +(a->b)+
* Then the functor will receive the function and will know how to unwrap the
value and after applying the function how to wrap it again.

==== Function (a->b)

A function represents a transformation applied to a given input, giving
a certain result.

We need a function adding 3 to any given number. Here is a simple java interface
defining a function:

[source,java]
.Function (Java)
----
include::{sourceDirJava}/groovyfp/categories/Function.java[indent=0] 
----

Because this interface is in fact a functional interface, it could be
substituted by a Closure expression. So instead of building a new class or
building a verbose inner class implementation we will be using a closure
to define a new implementation of the *Function* interface.

[source,groovy]
.Function<Integer,Integer>
----
include::{testDir}/groovyfp/categories/FunctionSpec.groovy[tags=function1,indent=0] 
----

NOTE: Be aware that because closures only declare the return type you should add 
the type to the closure parameter if you care about input type.

==== Functor<A>

Well now we need an instance of a functor of type *A*, pass to the functor
our previously created function and expect to receive a certain value with
a certain type.

[source,groovy]
.Functor<Integer>
----
include::{testDir}/groovyfp/categories/FunctorSpec.groovy[tags=functorspec1,indent=0] 
----

Ok but how +Maybe.Just+ gets something and transform it to another functor. Lets see
what the +fmap+ implementation does:

[source,java]
.Maybe Functor#fmap implementation
----
include::{sourceDirJava}/groovyfp/categories/Maybe.java[tags=functorspec2,indent=0]
----

First I'll try to describe which types are involved:

* +JUST+ is the value contained by the Maybe instance (which among other things is a functor).
* +<B>+ is the type of the function applied. Then
the Maybe implementation wraps that value into another instance of a functor
(this time another Just instance).

Basically here the +fmap+ method takes as an argument a function transforming
the contained value in the source functor and then wraps it again in another
functor instance. 

=== Applicative Functor

Remember I was saying a +Functor+ is a container, a box if you like, containing
a simple value ? You can think about +Applicative+ like a +Functor+ containing
a +Function+. This time the +box+ contains a +Function+.

Why then the name of +Applicative+ ? I'm not quite sure, but
I think it came from the idea that a function *can be applied* 
to some other values.

In Haskell:

[source,haskell]
----
(<*>) :: Applicative f => f (a->b) -> (f a -> f b)
----

==== Implementation

[source,java]
----
include::{sourceDirJava}/groovyfp/categories/Applicative.java[indent=0]
----
