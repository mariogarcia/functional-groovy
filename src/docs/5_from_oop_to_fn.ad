== OOP Revisited 

Most of the time is hard to think in terms of functional programming because we are not used to do
it. I was born as a programmer in OOP programming, and it's now when I've started digging into
functional programming.

So I guess that a friendly way of travelling to the functional land would be to pass through some of
the object-oriented places we've been working on for the past 20 years. Do you want to join me in
this trip ? Lets go!

I've followed the list of oop patterns discussed in the book "Functional Programming Patterns" by
Michael Bevilaqua-Linn.

Object oriented languages that doesn't have functions as first citizens have to make do with classes
and methods in order to be able to pass behavior to another classes or methods.

=== Replacing Functional Interface

The first example has to do with some of the topics we've seen so far. In previous chapters we've
been talking about how to filter and transform data with closures. Now we're going to measure how
far we are from the times we only could pass behavior using classes and methods.

Don't get me wrong, I'm not complaining, but we don't have to do that anymore, do we ?

How could do we pass filtering behavior to a collection if we didn't have closures ? I would start
by declaring an interface declaring the intent of the filter:

[source, groovy]
.Filter
----
include::{sourceDir}/groovyfp/oop2fn/Filter.groovy[indent=0] 
----

Then of course an implementation:

[source, groovy]
.Filter implementation
----
include::{sourceDir}/groovyfp/oop2fn/EvenNumbersFilter.groovy[indent=0] 
----

And that's it. We can now use it:

[source, groovy]
.How to use the functional interface
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_2,indent=0] 
----

[source, groovy]
.How to use the functional interface
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_1,indent=0] 
----

And now, how can we do the same in Groovy ? Well, in case we wanted to reuse the method receiving
the Filter instance we can use closures coercion:

[source, groovy]
.Closure coercion
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_3,indent=0] 
----

<1> Creation of an instance that implements the functional interface. The body of the closure is
supposed to be the implementation of the only method that the interface had.  
<2> Then you can use it whenever you used to pass an instance of that object

=== State

Closures have an important characteristic, which is they capture the "state" of the scope where they
were created.

IMHO the wrong way of thinking about this topic is the following example, which mutates
one of the references the closure is using.

[source, groovy]
.State (Wrong)
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_4,indent=0] 
----

<1> We declare a given discount to apply to some prices.
<2> The scope is so wide there is the risk someone could mutate the state reference value 
<3> The worst happened. We mutated state and the result of calling the closure with the same
value changes. If you care about mutability, this is not good.

How can we pass state without mutating references used by our closure. I've changed the
example a little bit:

[source, groovy]
.State
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_5,indent=0] 
----

<1> We declare the state at a given point
<2> We declare the closure, but notice that when the inner closure is created it only sees the
state when it was created nothing more.
<3> That's way when the state variable mutates the execution of the closure remains the same

=== Command

Command pattern normally wraps a certain behavior, and that behavior is passed to another function
or object to execute that behavior with the data found at the destination function or object.

Imagine I want to purchase online two tickets, and I can chose between paying the VIP tickets or the
regular ones. Depending on my choice the payment process will charge me differently.

[source, groovy]
.Object receiving command
----
include::{sourceDir}/groovyfp/oop2fn/PurchaseEntry.groovy[indent=0] 
----

The purchase order has the normal price of the purchase, and depending on the process applied, the
final amount could be changed.

[source, groovy]
.Contract of the command
----
include::{sourceDir}/groovyfp/oop2fn/PurchaseProcess.groovy[indent=0] 
----

All processes passed to the process entry, should comply to the PurchaseProcess interface. Remember
we can create a closure and coerce it to become a functional interface.

[source, groovy]
.Using command pattern
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_6,indent=0] 
----

<1> Initializing the entry with the initial price
<2> Applying each of the processes to check different values
<3> Declaring each process and the expected prices after applying those processes to the entry

=== Immutable objects instead of Builder

Six years ago I remember creating builder objects in Java not only because I was preserving
immutability (I didn't care about it at that time) but also because using a builder with a fluent
API (using the chain pattern of course) was like using a DSL.

Nowadays with Groovy both of those "requirements" can be achieved by using the @Immutable
transformation and the fact that you can use maps when building new instances of an object.

We want to build and immutable object, or an object as immutable as it could be. Our object
carries information about a given video. Here is the Java-Style builder.

[source, groovy]
.Using builder
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_6,indent=0] 
----


