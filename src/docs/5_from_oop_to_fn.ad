== OOP Revisited 

Most of the time is hard to think in terms of functional programming because we are not used to do
it. I was born as a programmer in OOP programming, and it's now when I've started digging into
functional programming.

So I guess that a friendly way of travelling to the functional land would be to pass through some of
the object-oriented places we've been working on for the past 20 years. Do you want to join me in
this trip ? Lets go!

I've followed the list of oop patterns discussed in the book "Functional Programming Patterns" by
Michael Bevilaqua-Linn.

Object oriented languages that doesn't have functions as first citizens have to make do with classes
and methods in order to be able to pass behavior to another classes or methods.

=== Replacing Functional Interface

The first example has to do with some of the topics we've seen so far. In previous chapters we've
been talking about how to filter and transform data with closures. Now we're going to measure how
far we are from the times we only could pass behavior using classes and methods.

Don't get me wrong, I'm not complaining, but we don't have to do that anymore, do we ?

How could do we pass filtering behavior to a collection if we didn't have closures ? I would start
by declaring an interface declaring the intent of the filter:

[source, groovy]
.Filter
----
include::{sourceDir}/groovyfp/oop2fn/Filter.groovy[indent=0] 
----

Then of course an implementation:

[source, groovy]
.Filter implementation
----
include::{sourceDir}/groovyfp/oop2fn/EvenNumbersFilter.groovy[indent=0] 
----

And that's it. We can now use it:

[source, groovy]
.How to use the functional interface
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_2,indent=0] 
----

[source, groovy]
.How to use the functional interface
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_1,indent=0] 
----

And now, how can we do the same in Groovy ? Well, in case we wanted to reuse the method receiving
the Filter instance we can use closures coercion:

[source, groovy]
.Closure coercion
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_3,indent=0] 
----

<1> Creation of an instance that implements the functional interface. The body of the closure is
supposed to be the implementation of the only method that the interface had.  
<2> Then you can use it whenever you used to pass an instance of that object

=== State

Closures have an important characteristic, which is they capture the "state" of the scope where they
were created.

IMHO the wrong way of thinking about this topic is the following example, which mutates
one of the references the closure is using.

[source, groovy]
.State (Wrong)
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_4,indent=0] 
----

<1> We declare a given discount to apply to some prices.
<2> The scope is so wide there is the risk someone could mutate the state reference value 
<3> The worst happened. We mutated state and the result of calling the closure with the same
value changes. If you care about mutability, this is not good.

How can we pass state without mutating references used by our closure. I've changed the
example a little bit:

[source, groovy]
.State
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_5,indent=0] 
----

<1> We declare the state at a given point
<2> We declare the closure, but notice that when the inner closure is created it only sees the
state when it was created nothing more.
<3> That's way when the state variable mutates the execution of the closure remains the same

=== Command

Command pattern normally wraps a certain behavior, and that behavior is passed to another function
or object to execute that behavior with the data found at the destination function or object.

Imagine I want to purchase online two tickets, and I can chose between paying the VIP tickets or the
regular ones. Depending on my choice the payment process will charge me differently.

[source, groovy]
.Object receiving command
----
include::{sourceDir}/groovyfp/oop2fn/PurchaseEntry.groovy[indent=0] 
----

The purchase order has the normal price of the purchase, and depending on the process applied, the
final amount could be changed.

[source, groovy]
.Contract of the command
----
include::{sourceDir}/groovyfp/oop2fn/PurchaseProcess.groovy[indent=0] 
----

All processes passed to the process entry, should comply to the PurchaseProcess interface. Remember
we can create a closure and coerce it to become a functional interface.

[source, groovy]
.Using command pattern
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_6,indent=0] 
----

<1> Initializing the entry with the initial price
<2> Applying each of the processes to check different values
<3> Declaring each process and the expected prices after applying those processes to the entry

=== Immutable objects instead of Builder

Six years ago I remember creating builder objects in Java not only because I was preserving
immutability (I didn't care about it at that time) but also because using a builder with a fluent
API (using the chain pattern of course) was like using a DSL.

Nowadays with Groovy both of those "requirements" can be achieved by using the @Immutable
transformation and the fact that you can use maps when building new instances of an object.

We want to build and immutable object, or an object as immutable as it could be. Our object
carries information about a given video. Here is the Java-Style builder.

[source, groovy]
.Video 
----
include::{sourceDir}/groovyfp/oop2fn/Video.groovy[indent=0] 
----

In order to make Video object immutable (and not using @Immutable as we will see later on) I came
with this idea of forcing to create all possible constructors to be able to initialize class fields
using constructors and then overriding the setters.

I guess it would be easier if we could declare fields as private and Groovy would care about private
but so far it doesn't. So even if the field is private you can access to it.

NOTE: Even in Java through the Reflection API you can access to the value of a private field.

Next is the builder itself. It has a fluent API so if you use an IDE you will be please about
concatenating builder methods to initialize and build a new instance of Video class.

[source, groovy]
.Video Builder
----
include::{sourceDir}/groovyfp/oop2fn/VideoBuilder.groovy[indent=0] 
----

Finally both classes interact together in the following specification.

[source, groovy]
.Using builder
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_7,indent=0] 
----

This is a lot of code right ? Since Groovy 1.7 *_@Immutable_* annotation is avaiable. This
annotation applies an AST transformation to make your classes almost immutable. To see the
particulars of what *_@Immutable_* can do for you, I'd recommend you to check the GroovyDoc, it's
very detailed.

[source, groovy]
.ImmutableVideo 
----
include::{sourceDir}/groovyfp/oop2fn/ImmutableVideo.groovy[indent=0] 
----

[source, groovy]
.Using @Immutable
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_8,indent=0] 
----

The main difference between the Builder instance and the use of the @Immutable annotation is that
the use of the annotation will thrown an exception every time you try to access to any of the fields
of the anotated class, while the instance built with the builder will just ignore your attempts to
change the value of your fields.

Maybe there are more solutions to that problem, like a friend of mine says....pull-requests are
welcome :-)

=== Replacing Iterator

Most of the ideas about this topic have been already discussed in link:3_iteration.html[Internal vs External Iteration].

The only idea I want to touch here is *_sequence comprehensions_*.

Why comprehensions are so appealling. Have you ever tried to loop through two collections at a time
to get values combined ? I'm sure you have. How did it look like ? I bet it was pretty much like this:

[source, groovy]
.Looping hell
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_9,indent=0] 
----

Unfortunately Groovy doesn't have comprehensions inbuilt in the language. But good news you have
some options. You can use *_Tim Yates'_* http://timyates.github.io/groovy-stream/[*_stream-groovy_*] library which have among others some
comprehensions implementation.

[source, groovy]
.stream-groovy comprehensions
----
include::{testDir}/groovyfp/oop2fn/ObjectOrientedPatternsSpec.groovy[tags=oop2fn_10,indent=0] 
----

=== Template pattern


