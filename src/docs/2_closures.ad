== Closures 

=== Definition

Until I find a better definition, I came up with the following "informal" definition: 

""
A *_closure_* is a function which allows access to variables declared in its surrounding scope when
the closure was declared.

Normally this surrounding scope in Groovy means local variables and non-local variables inside its
upper lexical scopes up to class fields.
""

The minimal version of a closure could be:

[source, groovy]
.Declaring a closure
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures1,indent=0] 
----

<1> A closure may have closure aguments
<2> A closure body may have statements
<3> A closure may have an implicit variable
<4> Closures always return a value (even though it could be void).

Closures can be declared in as class fields, static fields, and local variables.

NOTE: I've included the typed version because sometimes people forgot about the fact that a closure is a
function, and like any other function it could return something.

Lets review the principals of a closure:

[source, groovy]
.Using a closure
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures2,indent=0] 
----

<1> A closure can access non-local variables available in upper lexical scopes when the closure was declared
<2> A closure can access local variables
<3> Has its own execution body
<4> Because it is a function, can be executed

Closures may reference variables external to their own definition. This includes local variables,
method parameters, and object instance members. However, a closure may only reference those
variables that the compiler can lexically deduce from the physical location of the closure
definition within the source file.  

IMPORTANT: It's very important to keep in mind that a closure "sees" those variables available when the closure
was declared, not when it's used. 

=== Getting started 

Closures are widely used in Groovy. One of the most common places are collections. In the
following example we want to get 2 times each element of the collection.

[source, groovy]
.Using closures in API
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures3,indent=0] 
----

The collect method receives a parameter of type *_Closure_* that transforms every item in
the collection.

<1> Anonymous closure with implicit variable. In this case the variable refers to every
element in the collection.

You can also declare the closure and use it later as a parameter to another function.

[source, groovy]
.Using closures in API
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures4,indent=0] 
----

<1> Declaring the closure
<2> Passing closures as parameters to other functions (closures or methods) 

=== Composition

==== Applied to transformations

Sometimes we end with a lot of functions used all over the code, but many
times used in different ways, orders...etc.

Imagine you have a problem and you only know there will be two numbers
as an input and the result will be decimal. Your boss tells you to 
add them up until he knows what the final calculation will be.

Well it's not that bad isn't it ? It is going to be a simple sum, lets
hardcode it and leave it alone.

[source, groovy]
.Harcoding solution which is likely to change
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures5,indent=0] 
----

Now your boss comes again and gives you the whole formula: All numbers should be
multiplied 2 times and then be divided by 10 and eventually yes they should be
added up.

Ok, now you have to modify your code:

[source, groovy]
.Modifying your logic
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures6,indent=0] 
----

You may be thinking the code is still legibible and there is nothing wrong to
keep it that way. Well I disagree. First of all you are looping the collection
twice, that could be a lot of numbers, be carefull with that. And the second ...
will see that later ;)

I'm going to compose first two functions to be applied only once per item before
adding up all numbers.

[source, groovy]
.Composing
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures7,indent=0] 
----

<1> Declaring first part of the calculation
<2> Declaring second part of the calculation
<3> Combining both of them. Execution will be from left to right. First multiplication, 
then division
<4> Using the combined function per each item

Composition could be done from left to right or the other way around, it depends on the developer's
decision. But this has to change a little bit more. We still have our functions

[source, groovy]
.Composing
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures8,indent=0] 
----

<1> I've moved functions that I will probably reuse to static methods. That way I can
combine them without harcode them in my methods
<2> In this method I describe the problem I've been dealing with. Applying a function
to a list of numbers that eventually are going to be added up.
<3> I'm using the composed function here
<4> At this point I'm able to reuse the basic functionality to apply any single or
combined function to it.

==== Applied to filtering 

=== Currying

(TODO)

=== Delegation strategy

(TODO)

=== Memoization 

(TODO)

=== Trampoline 

(TODO)

=== Functional interface coercion

(TODO)

