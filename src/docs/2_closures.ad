== Closures 

=== Definition

Until I find a better definition, I came up with the following "informal" definition: 

""
A *_closure_* is a function which allows access to variables declared in its surrounding scope when
the closure was declared.

Normally this surrounding scope in Groovy means local variables and non-local variables inside its
upper lexical scopes up to class fields.
""

The minimal version of a closure could be:

[source, groovy]
.Declaring a closure
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures1,indent=0] 
----

<1> A closure may have closure aguments
<2> A closure body may have statements
<3> A closure may have an implicit variable
<4> Closures always return a value (even though it could be void).

Closures can be declared in as class fields, static fields, and local variables.

NOTE: I've included the typed version because sometimes people forgot about the fact that a closure is a
function, and like any other function it could return something.

Lets review the principals of a closure:

[source, groovy]
.Using a closure
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures2,indent=0] 
----

<1> A closure can access non-local variables available in upper lexical scopes when the closure was declared
<2> A closure can access local variables
<3> Has its own execution body
<4> Because it is a function, can be executed

Closures may reference variables external to their own definition. This includes local variables,
method parameters, and object instance members. However, a closure may only reference those
variables that the compiler can lexically deduce from the physical location of the closure
definition within the source file.  

IMPORTANT: It's very important to keep in mind that a closure "sees" those variables available when the closure
was declared, not when it's used. 

=== Getting started 

Closures are widely used in Groovy. One of the most common places are collections. In the
following example we want to get 2 times each element of the collection.

[source, groovy]
.Using closures in API
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures3,indent=0] 
----

The collect method receives a parameter of type *_Closure_* that transforms every item in
the collection.

<1> Anonymous closure with implicit variable. In this case the variable refers to every
element in the collection.

You can also declare the closure and use it later as a parameter to another function.

[source, groovy]
.Using closures in API
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures4,indent=0] 
----

<1> Declaring the closure
<2> Passing closures as parameters to other functions (closures or methods) 

=== Composition

Sometimes we end with a lot of functions used all over the code, but many
times used in different ways, orders...etc.

Imagine you have a problem and you only know there will be two numbers
as an input and the result will be decimal. Your boss tells you to 
add them up until he knows what the final calculation will be.

Well it's not that bad isn't it ? It is going to be a simple sum, lets
hardcode it and leave it alone.

[source, groovy]
.Harcoding solution which is likely to change
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures5,indent=0] 
----

Now your boss comes again and gives you the whole formula: All numbers should be
multiplied 2 times and then be divided by 10 and eventually yes they should be
added up.

Ok, now you have to modify your code:

[source, groovy]
.Modifying your logic
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures6,indent=0] 
----

You may be thinking the code is still legibible and there is nothing wrong to
keep it that way. Well I disagree. First of all you are looping the collection
twice, that could be a lot of numbers, be carefull with that. And the second ...
will see that later ;)

I'm going to compose first two functions to be applied only once per item before
adding up all numbers.

[source, groovy]
.Composing
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures7,indent=0] 
----

<1> Declaring first part of the calculation
<2> Declaring second part of the calculation
<3> Combining both of them. Execution will be from left to right. First multiplication, 
then division
<4> Using the combined function per each item

Composition could be done from left to right or the other way around, it depends on the developer's
decision. But this has to change a little bit more. We still have our functions

[source, groovy]
.Composing
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures8,indent=0] 
----

<1> I've moved functions that I will probably reuse to static methods. That way I can
combine them without harcode them in my methods
<2> In this method I describe the problem I've been dealing with. Applying a function
to a list of numbers that eventually are going to be added up.
<3> I'm using the composed function here
<4> At this point I'm able to reuse the basic functionality to apply any single or
combined function to it.

=== Currying

==== What is currying ? 

(TODO)

==== Using curry, ncurry, rcurry

(TODO)

==== Currying combining closures 

The same way we wanted to compose functions to transform values we may want to
do the same with filtering.

This time we will change the perspective. Instead of applying composed filter
I think is more interesting how to aggregate filters in order to apply them.

Think about an SQL operation, we wouln't want the database engine to apply 
each filter for every row and aggregate the result from the previous execution right ?
That would be crazy ? So if the database engine doesn't do it, neither do I.

Our starting point is the less efective implementation where we're repeating our
loop per each filter

[source, groovy]
.Filtering several times
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures9,indent=0] 
----

I can't combine both filters as I did with transformation in the previous chapter.  Because the
result of applying a filter is a boolean value. Than boolean value will be passed as the argument of
the next function in line, and it will fail because all our filters are expecting a number.

The strategy requires *_"currying"_*. 

Let's show how to do it with normal *_Xcurry_* methods. Beware this won't be nice :(

[source, groovy]
.Combining filters using rcurry 
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures10,indent=0] 
----

<1> First we create a closure with two parameters. We need to set the filters. All filters should be executed for every number
<2> We need to use rcurry to set filters, because var-args arguments can only be the last parameter of a function
<3> Passing all filter we want to apply in order
<4> Filtering numbers

[source, groovy]
.Combining filters using closure combination
----
include::{testDir}/groovyfp/closures/ClosuresSpec.groovy[tags=closures11,indent=0] 
----

<1> In just one call we are using the behavior of closures to set the filters we will be
using without having to use any Xcurry function
<2> Passing all filter we want to apply in order
<3> Filtering numbers

Why can I do step number 1 ? Because the closure's *filter* value is set when the closure is
declared with the references at that time.  Afterwards those values won't change. Anyway I made sure
that couln't happen because I declare *_filters_* as a *_final_* parameter.

=== Delegation strategy

(TODO)

=== Memoization 

(TODO)

=== Trampoline 

(TODO)

=== Functional interface coercion

(TODO)

